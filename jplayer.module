<?php
/**
 * @file
 * Provides an HTML5-compatible with Flash-fallback audio player.
 *
 * This module provides functionality for loading the jPlayer library and
 * formatters for File Fields.
 */

/**
 * Implements hook_menu().
 */
function jplayer_menu() {
  $items = array();

  $items['admin/config/media/jplayer'] = array(
    'title' => 'jPlayer',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('jplayer_settings_form'),
    'access arguments' => array('administer site configuration'),
    'description' => 'Configure the settings for the jPlayer module.',
    'file' => 'includes/jplayer.admin.inc',
  );
  
  $items['Player/%'] = array(
      'title' => t('Player'),
      'page callback' => 'play_callback',
      'page arguments' => array(1),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
  );
  
  return $items;
}

/****************************************************************************
 *******************************CUSTOM STUFF*********************************
 ****************************************************************************/

/**
 * Implements hook_help().
 */
function jplayer_help($path, $arg)
{
    switch($path) {
        case "admin/help#jplayer":
            return '<p>' . t("Plays audio to be transcribed!") . '</p>';
            break;
    }
}

/**
 * Implements hook_init().
 */
function jplayer_init() {
    
    $url = request_path();
    
    // Pause the player when user clicks ANNOTATE button
    drupal_add_js('jQuery(document).ready(function() {
        jQuery("#edit-annotate").click(function() {
            jQuery("*").jPlayer("pause");
        });
    });', 'inline');    // Using the * selector for now, but would be better if somehow the specific jplayer object ID could be obtained
    
    $action = 1;
    if(drupal_match_path($url, 'Transcriber/*')) {
        $action = 0;        
    }
    if(drupal_match_path($url, 'Player/*')) {
        $action = 1;
    }
    if(request_path() == 'content/annotator') {
        $action = 1;
    }
    drupal_add_js(array('jplayer' => array(
            'action' => $action,
    )), 'setting');
}

/**
 * Function to create a player when a link is clicked in a view
 */
function play_callback($nid) {
    $audio_node = node_load($nid);
    if($node = menu_get_object()) {
        // Do nothing
    }
    else {
        create_player_node('Player', $audio_node);
    }
}

/**
 * Function to create a jplayer node for segmented/normal audio playback.
 */
function create_player_node($content, $audio_file = NULL) {
    $node = new StdClass();
    $node->type = 'audio_player';
    node_object_prepare($node);
    
    $node->language = LANGUAGE_NONE;    
    $node->title = $content . ': ' . $audio_file->title;
    
    global $user;
    $node->uid = $user->uid;
    $node->name = $user->name;
    
    $node->status = 1;
    $node->promote = 0;
    $node->comment = 1;
    
    $alias = $content . '/' . $audio_file->nid;
    $node->field_audio[$node->language][0] = $audio_file->field_remote_file_url[$audio_file->language][0];
    $node->field_player_audio_file[$node->language][0]['target_id'] = $audio_file->nid;
    
    // Add an entity reference to the webform that was created for the transcript
    if($content == 'Transcriber') {
        $title = $audio_file->title . ' Transcript Form';
        $transcriber_player_nid = db_query('SELECT nid FROM {node} WHERE type = :type AND title = :title', array(':type' => 'webform', ':title' => $title))->fetchField();
        $node->field_transcript_form[$node->language][0]['target_id'] = $transcriber_player_nid;
    }
       
    $node->path = array('alias' => $alias);
    
    $node = node_submit($node);
    node_save($node);
}

/*******************************BASIC UI***************************************/

/**
 * Implements hook_block_info().
 */
function jplayer_block_info()
{   
    global $option;
    $option = 'none';
    $blocks['options'] = array(
        'info' => t('Options'),
        'cache' => DRUPAL_CACHE_GLOBAL,
    );    
    return $blocks;
}

/**
 * Implements hook_block_info_alter().
 */
function jplayer_block_info_alter(&$blocks, $theme, $code_blocks) {

    if(array_key_exists('transcript_edit-block', $blocks['views'])) {
        $blocks['views']['transcript_edit-block']['status'] = TRUE;
        $blocks['views']['transcript_edit-block']['region'] = 'content';
    }
    
    // Webform blocks
    if($player_node = menu_get_object()) {
        $transcript_form_exists = 0;
        $annotation_form_exists = 0;
        
        if($player_node->type == 'audio_player') {
            // Get the audio file and webform info
            $audio_file = node_load($player_node->field_player_audio_file[$player_node->language][0]['target_id']);
            
            // Check if it's an annotation or transcription form
            $t_title = $audio_file->title . ' Transcript Form';
            $a_title = $audio_file->title . ' Annotation Form';
            $transcript_form_exists = db_query('SELECT 1 FROM {node} WHERE type = :type AND title = :title', array(':type' => 'webform', ':title' => $t_title))->fetchField();
            $annotation_form_exists = db_query('SELECT 1 FROM {node} WHERE type = :type AND title = :title', array(':type' => 'webform', ':title' => $a_title))->fetchField();

            // Alter block configuration
            if($transcript_form_exists) {                
                $result = db_query('SELECT * FROM {node} WHERE type = :type AND title = :title', array(':type' => 'webform', ':title' => $t_title));
                $webform_nid = $result->fetchField(0);
                $delta = 'client-block-' . $webform_nid;
                $blocks['webform'][$delta]['status'] = TRUE;
                $blocks['webform'][$delta]['visibility'] = 1;
                $blocks['webform'][$delta]['region'] = 'content';
                $blocks['webform'][$delta]['pages'] = 'Transcriber/' . $audio_file->nid;
            }
            if($annotation_form_exists) {                
                $result = db_query('SELECT * FROM {node} WHERE type = :type AND title = :title', array(':type' => 'webform', ':title' => $a_title));
                $webform_nid = $result->fetchField(0);
                $delta = 'client-block-' . $webform_nid;
                $blocks['webform'][$delta]['status'] = TRUE;
                $blocks['webform'][$delta]['visibility'] = 1;
                $blocks['webform'][$delta]['region'] = 'content';
                $blocks['webform'][$delta]['pages'] = 'Annotator/' . $audio_file->nid;
            }
        }
    }
}

/**
 * Implements hook_block_view().
 */
function jplayer_block_view($delta = '')
{           
    $block = array();
    switch($delta) {
        case 'options':
            $block['content'] = drupal_get_form('getOptionsForm');
            break;
    }
    return $block;
}

/**
 * Options form function
 */
function getOptionsForm() {
    $form = array();
    $form['transcribe'] = array(
        '#type' => 'submit',
        '#value' => t('Transcribe'),
        '#submit' => array('transcribe_handler'),
    );
    $form['annotate'] = array(
        '#type' => 'submit',
        '#value' => t('Annotate'),
        '#submit' => array('annotate_handler'),
    );
    return $form;
}

/**
 * Implements hook_node_delete().
 */
function jplayer_node_delete($node) {
    if($node->type == 'webform') {
        // Delete the associated blocks from database
    }
}

/*************************TRANSCRIBER FUNCTIONS********************************/

/**
 * Submit button handlers for options form
 */
function transcribe_handler($form, &$form_state) {
    
    // Get the audio file node
    $player_node = menu_get_object();
    $audio_file = node_load($player_node->field_player_audio_file[$player_node->language][0]['target_id']);
    
    // Check if an associated transcriber already exists
    $title = 'Transcriber: ' . $audio_file->title;
    $node_title = db_query('SELECT title FROM {node} WHERE title = :title', array(':title' => $title))->fetchField();
    
    // If the node doesn't already exist
    if(empty($node_title)) {    
        // Create new audio_player node with an associated webform
        create_transcript_webform_node($audio_file->title);
        create_player_node('Transcriber', $audio_file);        
    }
    
    // Redirect to the transcriber
    $url = 'Transcriber/' . $audio_file->nid;
    drupal_goto($url);
}

/**
 * Create a new webform node for transcript
 */
function create_transcript_webform_node($file_name) {
    
    $rids = array();
    $result = db_query('SELECT * FROM {role}');
    foreach($result as $record) {
        $rids[] = $record->rid;
    }
    
    // Basic node creation
    $node = new StdClass();
    $node->type = 'webform';
    node_object_prepare($node);
    $node->title = $file_name . ' Transcript Form';
    $node->language = LANGUAGE_NONE;
    $node->body[LANGUAGE_NONE][0]['value'] = '';
    $node->body[LANGUAGE_NONE][0]['format'] = 'full_html';
    
    global $user;
    $node->uid = $user->uid;
    $node->name = $user->name;
    
    $node->status = 1;
    $node->promote = 0;
    $node->comment = 1;
    
    // Get number of segments from the javascript file
    $cookie_name = 'seginfo';
    if(isset($_COOKIE[$cookie_name])) {
        $duration = $_COOKIE[$cookie_name];
        $segments = ceil($duration/5);
    }
    else {
        drupal_set_message(t('Something went wrong. Start over?'), 'warning');
        $segments = 1;
    }
    $maxSegments = 6;
    $MAX_PAGES = ceil($segments/$maxSegments);
    
    $COMP_PER_PAGE = $maxSegments + 1;
    
    // Create webform components: textfields and page breaks
    for($i=0; $i<$MAX_PAGES; $i++) {
        /* Set page number for javascript to access
        (array('jplayer' => array(
            drupal_add_js'pageinfo' => $i,
        )), 'setting');*/
        for($j=0; $j<$COMP_PER_PAGE; $j++) {
            
            $index = ($COMP_PER_PAGE*$i)+$j;
            // Check if the required number of segments are created
            if($index == ($segments+$MAX_PAGES-1)) {
                break;
            }
            
            if($index%$COMP_PER_PAGE == 6) {
                // Check if the required number of segments are created
                if($index == ($MAX_PAGES * $COMP_PER_PAGE)-1) {
                    break;
                }
                            
                // Page break component
                $number = $i+1;                
                $components[$index] = array(
                    'name' => 'Page ' . $number,
                    'form_key' => 'page_' . $number,
                    'type' => 'pagebreak',
                    'weight' => $index,
                    'pid' => 0,
                    'value' => '',
                    'extra' => array(
                        'next_page_label' => 'Next',
                        'prev_page_label' => 'Previous',
                        'private' => 0,
                    ),
                    'page_num' => $number,
                );
                
            }
            else {               
                
                // Textfield component
                $number = $index + 1 - $i;                
                $components[$index] = array(
                    'name' => 'Segment ' . $number,
                    'form_key' => 'segment_' . $number,
                    'type' => 'textfield',
                    'mandatory' => 1,
                    'weight' => $index,
                    'pid' => 0,
                    'extra' => array(
                        'title_display' => 'before',
                        'private' => 0,
                    ),
                    'page_num' => $i+1,
                );
            }
            
        }
    }
    
    // If user is reviewing
    //global $user;
    //if(in_array('administrator', $user->roles)) {
        
        // Page break
        $components[] = array(
            'name' => 'Page ' . ($number+1),
            'form_key' => 'page_' . ($number+1),
            'type' => 'pagebreak',
            'weight' => $index,
            'pid' => 0,
            'value' => '',
            'extra' => array(
                'next_page_label' => 'Next',
                'prev_page_label' => 'Previous',
                'private' => 0,
            ),
            'page_num' => ($number+1),
        );
        
        // Comment box
        $components[] = array(
            'pid' => '0',
            'form_key' => 'comments',
            'name' => 'Comments',
            'type' => 'textarea',
            'value' => '',
            'extra' => 
            array (
                'description' => 'Only for quality control use. Reviewers can add their notes if a transcript is being marked for editing.',
                'title_display' => 'before',
                'description_above' => 0,
                'private' => 0,
                'wrapper_classes' => '',
                'css_classes' => '',
                'cols' => '',
                'rows' => '',
                'resizable' => 1,
                'disabled' => 0,
                'placeholder' => '',
                'attributes' => array(),
                'analysis' => false,
            ),
            'required' => '0',
            'weight' => ($index+1),
            'page_num' => $i,
        );
    //}
    
    /* Where to email it to?
    $emails = array(
        array(
            'email' => 'gurwinder@asu.edu',
            'subject' => 'default',
            'from_name' => 'default',
            'from_address'=> 'default',
            'template' => 'default',
            'excluded_components' => array(),
        ),
    );*/
    
    $node->webform = array(
        'confirmation' => '',
        'confirmation_format' => 'filtered_html',
        'redirect_url' => '<none>',
        'status' => '1',
        'block' => '1',
        'teaser' => '0',
        'allow_draft' => '1',
        'auto_save' => '0',
        'submit_notice' => '1',
        'submit_text' => '',
        'submit_limit' => '-1',
        'submit_interval' => '-1',
        'total_submit_limit' => '-1',
        'total_submit_interval' => '-1',
        'progressbar_bar' => '1',
        'progressbar_page_number' => '0',
        'progressbar_percent' => '0',
        'progressbar_pagebreak_labels' => '0',
        'progressbar_include_confirmation' => '0',
        'progressbar_label_first' => 'Start',
        'progressbar_label_confirmation' => 'Complete',
        'preview' => '0',
        'preview_next_button_label' => '',
        'preview_prev_button_label' => '',
        'preview_title' => '',
        'preview_message' => '',
        'preview_message_format' => 'filtered_html',
        'preview_excluded_components' => 
        array (
        ),
        'record_exists' => TRUE,
        'roles' => $rids,
        //'emails' => $emails,
        'components' => $components,
    );
    
    // Save the node
    $node = node_submit($node);
    node_save($node);    
}

/**
 * Steps to take after the transcript webform is submitted
 */
function submit_redirect_transcript($form, &$form_state) {

    global $user;
  
    // Get the relevant webform
    $webform_node = $form['#node'];
    
    // Get the corresponding audio file node
    $title = str_replace(' Transcript Form', '', $webform_node->title);
    $audio_file = node_load(db_query('SELECT * FROM {node} WHERE title = :title', array(':title' => $title))->fetchField(0));
    
    // Get the author    
    $creator = user_load($webform_node->uid);
    
    // Get the ID of the last complete submission (there should only be 1)
    $result = db_query("SELECT * FROM {webform_submissions} WHERE nid = :nid", array(':nid' => $webform_node->nid));
    $sid = $result->fetchField(0);
    // Get the data of the submission and save into an array
    $result = db_query("SELECT data FROM {webform_submitted_data} WHERE sid = :sid", array(':sid' => $sid));
    $raw_data = array();
    $segment = 0;
    foreach($result as $record) {
        $raw_data[$segment++] = $record->data;
    }
    
    // Delete the last element of the array (the comment box))
    unset($raw_data[count($raw_data)-1]);
    
    // Format the data
    $txt_data = format_data_txt($raw_data);
    $xml_data = format_data_xml($audio_file, $raw_data, date('m/d/y H:i:s'), $creator);
    
    // Write transcript data to file
    $dest = 'public://transcripts/transcript' . $sid . '_' . REQUEST_TIME . '.xml';
    $file_object = file_save_data($xml_data, $dest, FILE_EXISTS_RENAME);
    if(!empty($file_object)) {
        create_transcript_node($audio_file, $dest, $txt_data, $creator);
    
        // Send an email to the author
        $to = $creator->mail;
        $key = 'notice';
        $language = $creator->language;
        $from = $user->mail;
        $body[] = 'Your transcript was reviewed by ' . $user->name . ' and has been published.';
        $params = array(
            'body' => $body,
            'subject' => 'Transcript Reviewed: Published',
        );
        drupal_mail('jplayer', $key, $to, $language, $params, $from, TRUE);
        
        // Get node ID and delete the transcriber player
        $title = 'Transcriber: ' . $audio_file->title;
        $result1 = db_query('SELECT * FROM {node} WHERE type = :type AND title = :title', array(':type' => 'audio_player', ':title' => $title));
        $nid1 = $result1->fetchField(0);
        node_delete($nid1);
        
        // Get node ID and delete the webform
        $title = $audio_file->title . ' Transcript Form';
        $result2 = db_query('SELECT * FROM {node} WHERE type = :type AND title = :title', array(':type' => 'webform', ':title' => $title));
        $nid2 = $result2->fetchField(0);
        node_delete($nid2);
        
        drupal_set_message(t('Your data has been saved'));
        $redirect_url = 'Player/' . $audio_file->nid;
        drupal_goto($redirect_url);
    }
    else {
        // Get node ID and delete the transcriber player
        $title = 'Transcriber: ' . $audio_file->title;
        $result1 = db_query('SELECT * FROM {node} WHERE type = :type AND title = :title', array(':type' => 'audio_player', ':title' => $title));
        $nid1 = $result1->fetchField(0);
        node_delete($nid1);
        
        // Get node ID and delete the transcript webform
        $title = $file_name . ' Transcript Form';
        $result2 = db_query('SELECT * FROM {node} WHERE type = :type AND title = :title', array(':type' => 'webform', ':title' => $title));
        $nid2 = $result2->fetchField(0);
        node_delete($nid2);
        
        drupal_set_message(t('Failed to save data'), 'error');
        $redirect_url = 'Player/' . $audio_file->nid;
        drupal_goto($redirect_url);
    }
}

/**
 * Format the transcript to a timestamped text file
 */
function format_data_txt($raw_data) {
    
    $data = array();
    for($segment=0; $segment<count($raw_data); $segment++) {
        // Calculate the timestamp
        $seconds = $segment * 5;
        $hours = sprintf('%02d', floor($seconds / 3600));
        $mins = sprintf('%02d', floor(($seconds - ($hours*3600)) / 60));
        $secs = sprintf('%02d', floor($seconds % 60));
        $timestamp = $hours . ':' . $mins . ':' . $secs;
                
        // Concatenate the timestamp with the data
        $data[$segment] = $timestamp . "\t" . $raw_data[$segment];
    }
    $formatted_string = $data[0];
    for($segment=1; $segment<count($data); $segment++) {
        $formatted_string = $formatted_string . "\r\n" . $data[$segment];
    }
    return $formatted_string;    
}

/**
 * Format the data into a TEI compliant XML file
 */
function format_data_xml($audio_file, $raw_data, $submit_time, $creator) {
    
    // Get username 
    $author = $creator->name;
    $author_email = $creator->mail;
    
    // Get number of segments from the javascript file
    $cookie_name = 'seginfo';
    if(isset($_COOKIE[$cookie_name])) {
        $duration = $_COOKIE[$cookie_name];
    }
    $segments = ceil($duration/5);
    
    $hours = sprintf('%02d', floor($duration / 3600));
    $mins = sprintf('%02d', floor(($duration - ($hours*3600)) / 60));
    $secs = sprintf('%02d', floor($duration % 60));
    $timestamp = $hours . ':' . $mins . ':' . $secs;
    
    $audio_file_name = $audio_file->title;
    $audio_path = $audio_file->field_remote_file_url[$audio_file->language][0]['uri'];
    $file_order = $audio_file->field_interview_file_order[$audio_file->language][0]['value'];
    
    // Get collection (distributor?)
    $collection_nid = $audio_file->field_collection[$audio_file->language][0]['target_id'];
    $collection_node = node_load($collection_nid);
    $distributor = $collection_node->title;
    
    // XML File
    $formatted_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n"
            . "<TEI>\r\n"
            . "\t<teiHeader>\r\n"
            . "\t\t<fileDesc>\r\n"
            . "\t\t\t<titleStmt>\r\n"
            . "\t\t\t\t<title>" . $audio_file_name . " Transcription</title>\r\n"
            . "\t\t\t\t<author>" . $author . "</author>\r\n"
            . "\t\t\t\t<respStmt>\r\n"
            . "\t\t\t\t\t<resp>Transcription of audio into text</resp>\r\n"
            . "\t\t\t\t</respStmt>\r\n"
            . "\t\t\t</titleStmt>\r\n"
            . "\t\t\t<extent>" . $timestamp . "</extent>\r\n"
            . "\t\t\t<publicationStmt>\r\n"
            . "\t\t\t\t<distributor>" . $distributor . "</distributor>\r\n"
            . "\t\t\t\t<availability><p>Available for educational and research purposes.</p></availability>\r\n"
            . "\t\t\t</publicationStmt>\r\n"
            . "\t\t\t<sourceDesc>\r\n"
            . "\t\t\t\t<recordingStmt>\r\n"
            . "\t\t\t\t\t<recording type=\"audio\" corresp=\"" . $audio_path . "\"/>\r\n"
            . "\t\t\t\t</recordingStmt>\r\n"
            . "\t\t\t</sourceDesc>\r\n"
            . "\t\t</fileDesc>\r\n"
            . "\t\t<encodingDesc>\r\n"
            . "\t\t\t<editorialDecl>\r\n"
            . "\t\t\t\t<normalization>\r\n"
            . "\t\t\t\t\t<p>The words on the recording should be written down in normal spelling using \"dictionary spelling.\" Transcribers should not attempt to use special spellings to represent pronunciation. The test is whether the spelling can be found in a standard dictionary. Some words may not be in a standard dictionary; transcribers should just do the best they can on those, and mark them with ?.</p>\r\n"
            . "\t\t\t\t</normalization>\r\n"
            . "\t\t\t\t<interpretation>\r\n"
            . "\t\t\t\t\t<p>Transcribers should not try to force the words into grammatical sentences, but instead should write down what people actually say, even if it appears to be ungrammatical (this is quite normal in conversation). Transcribers should mark \"sentence units\" (word groups thought by the transcriber to hold together in some way) with a capital letter at the beginning, and a period and one space at the end. Other use of caps and periods should be limited, and periods should not be followed by spaces unless at the end of a sentence unit. Proper names should be capitalized, but no caps or periods should be used with titles like mr or mrs or dr, and other abbreviations should be avoided as much as possible. Use ? to mark questions. Do not use : or ; and use the comma as little as possible (only when the interpretation of the utterance would otherwise be unclear to the user).</p>\r\n"
            . "\t\t\t\t</interpretation>\r\n"
            . "\t\t\t</editorialDecl>\r\n"
            . "\t\t</encodingDesc>\r\n"
            . "\t\t<revisionDesc>\r\n"
            . "\t\t\t<change who=\"" . $author . "\"  contact=\"" . $author_email . "\" when=\"" . $submit_time . "\"> Transcribed interview audio.</change>\r\n"
            . "\t\t</revisionDesc>\r\n"
            . "\t</teiHeader>\r\n"
            . "\t<text>\r\n"
            . "\t\t<body>\r\n"
            . "\t\t\t<timeline origin=\"#TS-p1\" unit=\"s\">\r\n"
            . "\t\t\t\t<when xml:id=\"TS-p1\" absolute=\"00:00:00\"/>\r\n";
    
    for($i=2; $i<=$segments+1; $i++) {
        $formatted_string .= "\t\t\t\t<when xml:id=\"TS-p" . $i . "\" interval=\"5.0\" since=\"TS-p" . ($i-1) . "\"/>\r\n";
    }
    
    $formatted_string = $formatted_string . "\t\t\t</timeline>\r\n"
            . "\t\t\t<div type=\"audio file\" n=\"" . $file_order . "\">\r\n";
    
    for($i=0; $i<$segments; $i++) {
        $formatted_string = $formatted_string. "\t\t\t\t<seg xml:id=\"TS-u" . ($i+1) . "\" start=\"#TS-p" . ($i+1) . "\" end=\"#TS-p" . ($i+2) . "\">\r\n"
                . "\t\t\t\t\t<u>\r\n\t\t\t\t\t" . $raw_data[$i] . "\r\n\t\t\t\t\t</u>\r\n"
                . "\t\t\t\t</seg>\r\n";
    }
    
    $formatted_string = $formatted_string . "\t\t\t</div>\r\n"
            . "\t\t</body>\r\n"
            . "\t</text>\r\n"
            . "</TEI>\r\n";
    
    return $formatted_string;    
}

/**
 * Create a new node for the transcript
 */
function create_transcript_node($file_node, $filepath, $txt_data, $creator) {
    
    // Basic node creation
    $node = new stdClass();
    $node->type = 'transcript';
    $node->language = LANGUAGE_NONE;
    node_object_prepare($node);
    
    $node->title = $file_node->title . ' Transcript';    
    $node->status = 1;
    $node->promote = 0;
    $node->comment = 1;
    $node->uid = $creator->uid;
    $node->name = $creator->name;
    
    // Add body
    $node->body[LANGUAGE_NONE][0]['value'] = $txt_data;
    
    // Add entity reference to audio
    $node->field_audio_file[$node->language][0]['target_id'] = $file_node->nid;
            
    // Add file
    $file = new stdClass();    
    $file->uri = $filepath;
    $file->filemime = file_get_mimetype($file->uri);
    $file->status = 1;
    $file->display = 1;
    $file = file_copy($file, 'public://');
    $node->field_transcript_download[$node->language][0] = (array)$file;
    
    $node = node_submit($node);
    node_save($node);
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function jplayer_form_webform_client_form_alter(&$form, &$form_state) {
    
    global $user;
    
    // If it's a transcript form
    if(strpos($form['#node']->title, 'Transcript') != FALSE) {
        
        // If there's a submit button, run custom submit code after the default submit behavior
        if(array_key_exists('submit', $form['actions'])) {        
            $form['actions']['submit']['#submit'] = array(
                0 => 'webform_client_form_pages',
                1 => 'webform_client_form_submit',
                2 => 'submit_redirect_transcript',
            );
        }    
    
        if(in_array('quality control', $user->roles)) {
            // Show the actual Submit button
            $form['actions']['submit']['#access'] = TRUE;
            // Show the comments box
            $form['submitted']['comments']['#attributes'] = array('enabled' => '1');
            if(array_key_exists('review', $form['actions'])) {
                $form['actions']['review']['#access'] = FALSE;
            }
            // Check if it's the last page
            if(!array_key_exists('next', $form['actions'])) {
                $form['actions']['Return for Editing'] = array(
                    '#type' => 'submit',
                    '#value' => 'Return for Editing',
                    '#submit' => array('edit_callback'),
                );
            }
        }
        elseif(in_array('authenticated user', $user->roles)) {
            // Hide the actual submit button
            $form['actions']['submit']['#access'] = FALSE;
            // Make the comments box read-only
            $form['submitted']['comments']['#attributes'] = array('disabled' => '1');
            // Check if it's the last page and add a 'Submit for Review' button
            if(!array_key_exists('next', $form['actions'])) {
                $form['actions']['review'] = array(
                    '#type' => 'submit',
                    '#value' => 'Submit for Review',
                    '#submit' => array('review_callback'),
                );
            }
        }
    }
    
    elseif(strpos($form['#node']->title, 'Annotation') != FALSE) {        
        $form['#submit'][] = 'submit_redirect_annotation';
    }
}

/**
 * Steps to take when a transcript is submitted for review
 */
function review_callback($form, &$form_state) {
    
    // Save the form as a draft
    force_save($form, $form_state);
    
    // Find the author who created this transcript
    $node = $form['#node'];
    $creator_uid = $node->uid;
    $creator = user_load($creator_uid);
    
    // Fill out mail params
    $from = $creator->mail;
    $key = 'notice';
    $body[] = 'A transcript has been submitted for review by ' . $creator->name . ' and needs review. Please review as soon as possible.';
    $params = array(
        'body' => $body,
        'subject' => 'Transcript Submitted for Review',
    );
    
    // Get all the users who are reviewers
    $uid = array();
    $result = db_query('SELECT * FROM {role} WHERE name = :name', array(':name' => 'administrator'));
    $rid = $result->fetchField(0);
    $result = db_query('SELECT * FROM {users_roles} WHERE rid = :rid', array(':rid' => $rid));
    foreach($result as $record) {
        $uid[] = $record->uid;
    }
    
    // Notify reviewer(s) that this transcript is ready for review
    foreach($uid as $id) {
        if($id == $creator_uid) {
            // Don't send email to self
            continue;
        }
        $reviewer = user_load($id);
        $to = $reviewer->mail;
        $language = $reviewer->language;
        drupal_mail('jplayer', $key, $to, $language, $params, $from, TRUE);
    }
    
    drupal_set_message('Your transcript has been submitted for review!');
    
    // Get the transcriber player node
    $title = str_replace(' Transcript Form', '', $node->title);
    $file_node = node_load(db_query('SELECT nid FROM {node} WHERE type = :type AND title = :title', array(':type' => 'audio_file', ':title' => $title))->fetchField());
    $redirect_url = 'Player/' . $file_node->nid;
    drupal_goto($redirect_url);
}

/**
 * Steps to take when a transcript is returned for editing
 */
function edit_callback($form, &$form_state) {
    global $user;
    // Save any changes the reviewer may have made
    force_save($form, $form_state);
    
    // Find the author who created this transcript
    $node = $form['#node'];
    $creator_uid = $node->uid;
    $creator = user_load($creator_uid);
    
    // Send an email to the author
    $to = $creator->mail;
    $key = 'notice';
    $language = $creator->language;
    $from = $user->mail;
    $body[] = 'Your transcript was reviewed by ' . $user->name . ' and needs to be edited. The reviewer may have added more information on the last page of the transcript form under \'Comments\'. Please update the transcript as soon as possible.';
    $params = array(
        'body' => $body,
        'subject' => 'Transcript Reviewed: Needs Attention',
    );
    drupal_mail('jplayer', $key, $to, $language, $params, $from, TRUE);
    
    drupal_set_message('The transcript has been marked for editing.');
    
    // Get the transcriber player node
    $title = str_replace(' Transcript Form', '', $node->title);
    $file_node = node_load(db_query('SELECT nid FROM {node} WHERE type = :type AND title = :title', array(':type' => 'audio_file', ':title' => $title))->fetchField());
    $redirect_url = 'Player/' . $file_node->nid;
    drupal_goto($redirect_url);
}

/**
 * Function to save webform data as a draft
 */
function force_save($form, &$form_state) {
    global $user;
    $draft_sid = _webform_fetch_draft_sid($form['#node']->nid, $user->uid);    
    $form_state['values']['details']['sid'] = $draft_sid;
    $form_state['values']['op'] = !empty($form['actions']['draft']['#value']) ? $form['actions']['draft']['#value'] : t('Save Draft');    
    $form_state['save_draft'] = TRUE;
    webform_client_form_pages($form, $form_state);
    webform_client_form_submit($form, $form_state);
}

/**
 * Implements hook_mail().
 */
function jplayer_mail($key, &$message, $params) {
    $headers = array(
        'MIME-Version' => '1.0',
        'Content-Type' => 'text/html; charset=UTF-8;',
        'Content-Transfer-Encoding' => '8Bit',
        'X-Mailer' => 'Drupal'
    );

    foreach ($headers as $key => $value) {
        $message['headers'][$key] = $value;
    }

    $message['subject'] = $params['subject'];
    $message['body'] = $params['body'];    
}

/**
 * Implements hook_webform_submission_load().
 *
function jplayer_webform_submission_load(&$submissions) {
    
    // Load the transcriber audio player node
    $submission = reset($submissions);
    $webform_node = node_load($submission->nid);
    $transcriber_title = 'Transcriber: ' . str_replace(' Transcript Form', '', $webform_node->title);
    //$transcriber_node = node_load(db_query('SELECT * FROM {node} WHERE title = :title', array(':title' => $transcriber_title))->fetchField(0));
    
}*/

/*************************ANNOTATOR FUNCTIONS**********************************/

/**
 * Steps to take after the annotation webform is submitted
 */
function annotate_handler($form, &$form_state) {
    
    // Get the audio file node
    $player_node = menu_get_object();
    $audio_file = node_load($player_node->field_player_audio_file[$player_node->language][0]['target_id']);
    
    // Check if an associated annotator already exists
    $title = 'Annotator: ' . $audio_file->title;
    $node_title = db_query('SELECT title FROM {node} WHERE title = :title', array(':title' => $title))->fetchField();
    
    // If the node doesn't already exist
    if(empty($node_title)) { 
        // Create new audio_player node with an associated webform
        create_player_node('Annotator', $audio_file);
        create_annotation_webform_node($audio_file->title);
    }
    
    // Redirect to the annotator
    $url = 'Annotator/' . $audio_file->nid;
    drupal_goto($url);
}

/**
 * Create a new webform node for annotation
 */
function create_annotation_webform_node($file_name) {
    
    // Get controlled taxonomy terms
    $string = '';
    $ctrl_term = taxonomy_get_tree(2, 0 , NULL, FALSE);
    foreach($ctrl_term as $term) {
        $string = $string . $term->name . '|' . $term->name . "\r\n";
    }
    
    // Basic node creation
    $node = new StdClass();
    $node->type = 'webform';
    node_object_prepare($node);
    $node->title = $file_name . ' Annotation Form';
    $node->language = LANGUAGE_NONE;
    $node->body[$node->language][0]['value'] = '';
    $node->body[$node->language][0]['format'] = 'full_html';
    
    /*global $user;
    $node->uid = $user->uid;*/
    
    $node->promote = 0;
    $node->comment = 1;
    
    $components = array(
        1 => array (
            'cid' => '1',
            'pid' => '0',
            'form_key' => 'type',
            'name' => 'Type',
            'type' => 'select',
            'value' => '',
            'extra' => array (
                'items' => 'ctrl|Controlled
uctrl|Uncontrolled',
                'multiple' => 0,
                'title_display' => 'before',
                'description_above' => 0,
                'private' => 0,
                'wrapper_classes' => '',
                'css_classes' => '',
                'aslist' => 0,
                'empty_option' => '',
                'optrand' => 0,
                'other_option' => NULL,
                'other_text' => 'Other...',
                'description' => '',
                'custom_keys' => false,
                'options_source' => '',
                'analysis' => true,
            ),
            'required' => '1',
            'weight' => '0',
            'page_num' => 1,
        ),
        2 => array (
            'cid' => '2',
            'pid' => '0',
            'form_key' => 'enter_annotation',
            'name' => 'Enter Annotation',
            'type' => 'textfield',
            'value' => '',
            'extra' => array (
                'title_display' => 'before',
                'description_above' => 0,
                'private' => 0,
                'wrapper_classes' => '',
                'css_classes' => '',
                'width' => '',
                'maxlength' => '',
                'field_prefix' => '',
                'field_suffix' => '',
                'disabled' => 0,
                'unique' => 0,
                'description' => '',
                'placeholder' => '',
                'attributes' => array (
                ),
                'analysis' => false,
            ),
            'required' => '1',
            'weight' => '1',
            'page_num' => 1,
        ),
        3 => array (
            'cid' => '3',
            'pid' => '0',
            'form_key' => 'select_annotation',
            'name' => 'Select Annotation',
            'type' => 'select',
            'value' => '',
            'extra' => array (
                'items' => $string,
                'multiple' => 0,
                'title_display' => 'before',
                'description_above' => 0,
                'private' => 0,
                'wrapper_classes' => '',
                'css_classes' => '',
                'aslist' => 0,
                'empty_option' => '',
                'optrand' => 0,
                'other_option' => NULL,
                'other_text' => 'Other...',
                'description' => '',
                'custom_keys' => false,
                'options_source' => '',
                'analysis' => true,
            ),
            'required' => '1',
            'weight' => '2',
            'page_num' => 1,
        ),       
    );
    
    $conditionals = array(       
        0 => array (
            'rgid' => '0',
            'andor' => NULL,
            'weight' => '-1',
            'rules' => array (
                0 => array (
                    'rgid' => '0',
                    'rid' => '0',
                    'source_type' => 'component',
                    'source' => '1',
                    'operator' => 'equal',
                    'value' => 'ctrl',
                ),
            ),
            'actions' => array (
                0 => array (
                    'rgid' => '0',
                    'aid' => '0',
                    'target_type' => 'component',
                    'target' => '3',
                    'invert' => '0',
                    'action' => 'show',
                    'argument' => '',
                ),
            ),
        ),
        1 => array (
            'rgid' => '1',
            'andor' => NULL,
            'weight' => '0',
            'rules' => array (
                0 => array (
                    'rgid' => '1',
                    'rid' => '0',
                    'source_type' => 'component',
                    'source' => '1',
                    'operator' => 'equal',
                    'value' => 'uctrl',
                ),
            ),
            'actions' => array (
                0 => array (
                    'rgid' => '1',
                    'aid' => '0',
                    'target_type' => 'component',
                    'target' => '2',
                    'invert' => '0',
                    'action' => 'show',
                    'argument' => '',
                ),
            ),
        ),
    );
    
    $node->webform = array(
        'next_serial' => '1',
        'confirmation' => '',
        'confirmation_format' => 'filtered_html',
        'redirect_url' => '<none>',
        'status' => '1',
        'block' => '1',
        'allow_draft' => '0',
        'auto_save' => '0',
        'submit_notice' => '1',
        'confidential' => '0',
        'submit_text' => '',
        'submit_limit' => '-1',
        'submit_interval' => '-1',
        'total_submit_limit' => '-1',
        'total_submit_interval' => '-1',
        'progressbar_bar' => '0',
        'progressbar_page_number' => '0',
        'progressbar_percent' => '0',
        'progressbar_pagebreak_labels' => '0',
        'progressbar_include_confirmation' => '0',
        'progressbar_label_first' => 'Start',
        'progressbar_label_confirmation' => 'Complete',
        'preview' => '0',
        'preview_next_button_label' => '',
        'preview_prev_button_label' => '',
        'preview_title' => '',
        'preview_message' => '',
        'preview_message_format' => 'filtered_html',
        'preview_excluded_components' => array (
        ),
        'record_exists' => true,
        'roles' => array (
            0 => '1',
            1 => '2',
        ),
        'emails' => array (
        ),
        'components' => $components,
        'conditionals' => $conditionals,
    );
    
    node_save($node);
}

/**
 * Steps to take after the annotation webform is submitted
 */
function submit_redirect_annotation($form, &$form_state) {
    
    // Get timestamp from the javascript file
    $cookie_name = 'timeinfo';
    if(isset($_COOKIE[$cookie_name])) {
        $timepoint = $_COOKIE[$cookie_name];
    }
    else {
        $timepoint = 0;
    }
    
    // Format the times tamp to HH:MM:SS
    $hours = sprintf('%02d', floor($timepoint / 3600));
    $mins = sprintf('%02d', floor(($timepoint - ($hours*3600)) / 60));
    $secs = sprintf('%02d', floor($timepoint % 60));
    $timestamp = $hours . ':' . $mins . ':' . $secs;
    
    // Get the relevant webform
    $webform_node = $form['#node'];
    
    // Load the audio player and get the corresponding audio file node
    $title = str_replace(' Transcript Form', '', $webform_node->title);
    $file_node = node_load(db_query('SELECT nid FROM {node} WHERE type = :type AND title = :title', array(':type' => 'audio_file', ':title' => $title))->fetchField());
    
    // Get the author    
    $creator = user_load($webform_node->uid);
    
    // Get the ID of the last complete submission
    $result = db_query("SELECT * FROM {webform_submissions} WHERE nid = :nid", array(':nid' => $webform_node->nid));
    $sid = $result->fetchField(0);
    
    // Get the data of the last submission and save into an array
    $result = db_query("SELECT data FROM {webform_submitted_data} WHERE sid = :sid", array(':sid' => $sid));
    $raw_data = array();
    $i = 0;
    foreach($result as $record) {
        $raw_data[$i++] = $record->data;
    }
    
    // Create the taxonomy term and get term ID
    if($raw_data[0] == 'ctrl') {
        $data = $raw_data[2];
        $tid = get_tid($data, 'annotation_categories_controlled_');
        $type = 'controlled';
    }
    else {
        $data = $raw_data[1];
        $exists = create_taxonomy_term($data);
        if($exists == 0) {
            $tid = get_tid($data, 'annotation_categories_uncontrolled_');
            $type = 'uncontrolled';
        }
        else {
            $tid = get_tid($data, 'annotation_categories_controlled_');
            $type = 'controlled';
        }
    }
    
    // Check if the annotation already exists; create one if not
    $node_name = $audio_file->title . ' Annotation @ ' . $timestamp;
    $result = db_query('SELECT * FROM {node} WHERE type = :type AND title = :title', array(':type' => 'annotation', ':title' => $node_name));
    $anode = $result->fetchField(0);
    if($anode == NULL) {
        create_annotation_node($audio_file, $tid, $type, $timestamp);
    }
    else {
        modify_annotation_node($anode, $tid, $type);
    }
    
    // Get node ID and delete the annotator player
    $title = 'Annotator: ' . $audio_file->title;
    $result1 = db_query('SELECT * FROM {node} WHERE type = :type AND title = :title', array(':type' => 'audio_player', ':title' => $title));
    $nid1 = $result1->fetchField(0);
    node_delete($nid1);
        
    // Get node ID and delete the annotation webform
    $title = $audio_file->title . ' Annotation Form';
    $result2 = db_query('SELECT * FROM {node} WHERE type = :type AND title = :title', array(':type' => 'webform', ':title' => $title));
    $nid2 = $result2->fetchField(0);
    node_delete($nid2);        
        
    drupal_set_message(t('The annotation has been added!'));
    $redirect_url = 'Player/' . $audio_file->nid;
    drupal_goto($redirect_url);
}

/**
 * Function to create a taxonomy term
 */
function create_taxonomy_term($new_term) {
    // Check if the term already exists in the controlled vocab
    $ctrl_vid = 2;
    $uctrl_vid = 3;
    $ctrl_term = taxonomy_get_tree($ctrl_vid, 0, NULL, FALSE);
    foreach($ctrl_term as $term) {
        if($new_term == $term->name) {
            drupal_set_message(t('The term already exists in the controlled vocabulary and will not be created.'), 'warning');
            return 1;
        }
    }
    $uctrl_term = taxonomy_get_tree($uctrl_vid, 0, NULL, FALSE);
    foreach($uctrl_term as $term) {
        if($new_term == $term->name) {
            drupal_set_message(t('The term already exists in the uncontrolled vocabulary and will not be created.'), 'warning');
            return 0;
        }
    }
    $term = new StdClass();
    $term->name = $new_term;
    $term->vid = $uctrl_vid; // For uncontrolled vocab    
    taxonomy_term_save($term);
    drupal_set_message(t('The term has been created!'));
    return 0;
}

/**
 * Function to get tid from term name
 */
function get_tid($term_name, $vocabulary) {
    $arr_terms = taxonomy_get_term_by_name($term_name, $vocabulary);
    if (!empty($arr_terms)) {
        $arr_terms = array_values($arr_terms);
        $tid = $arr_terms[0]->tid;
    }
    return $tid;
}

/**
 * Create a new node for the annotation
 */
function create_annotation_node($audio_file, $tid, $type, $timestamp) {
    // Basic node creation
    $node = new stdClass();
    $node->type = 'annotation';
    $node->language = LANGUAGE_NONE;
    node_object_prepare($node);
    
    
    $title = $audio_file->title;
    $node->title = $title . ' Annotation @ ' . $timestamp;
    
    $node->status = 1;
    $node->promote = 0;
    $node->comment = 1;    
    
    // Add entity reference to audio
    $node->field_annotation_audio_file[$node->language][0]['target_id'] = $audio_file->nid;
    
    // Add annotations
    if($type == 'controlled') {
        $node->field_controlled_annotations[$node->language][]['tid'] = $tid;
    }
    else {
        $node->field_uncontrolled_annotations[$node->language][]['tid'] = $tid;
    }
    
    // Add timestamp
    $node->field_timestamp[$node->language][0]['value'] = $timestamp;
    
    node_save($node);
}

/**
 * Function to add terms to existing annotation nodes
 */
function modify_annotation_node($anode, $tid, $type) {
    $node = node_load($anode);
    // Add annotations
    if($type == 'controlled') {
        $node->field_controlled_annotations[$node->language][]['tid'] = $tid;
    }
    else {
        $node->field_uncontrolled_annotations[$node->language][]['tid'] = $tid;
    }
    node_save($node);
}

/****************************************************************************
 *****************************END OF CUSTOM STUFF****************************
 ****************************************************************************/

/**
 * Implements hook_theme().
 */
function jplayer_theme() {
  return array(
    'jplayer' => array(
      'template' => 'theme/jplayer',
      'variables' => array(
        'entity_type' => NULL,
        'entity' => NULL,
        'field_name' => NULL,
        'items' => array(),
        'settings' => array(),
        'type' => '',
        'playlist' => '',
      ),
      'file' => 'includes/jplayer.theme.inc',
    ),
    'jplayer_item_list' => array(
      'render element' => 'element',
      'file' => 'includes/jplayer.theme.inc',
      'variables' => array(
        'items' => array(),
        'title' => NULL,
        'type' => 'ul',
        'attributes' => array(),
      ),
    ),
    'jplayer_view_playlist' => array(
      'template' => 'theme/jplayer',
      'arguments' => array('view' => NULL, 'items' => NULL),
      'file' => 'includes/jplayer.theme.inc',
    ),
  );
}

/**
 * Implements hook_field_formatter_info().
 */
function jplayer_field_formatter_info() {
  return array(
    'jplayer_player' => array(
      'label' => t('jPlayer - Player'),
      'field types' => array('file'),
      'description' => t('Display file fields as an HTML5-compatible with Flash-fallback media player.'),
      'settings' => array(
        'autoplay' => 0,
        'solution' => 'html, flash',
        'preload' => 'metadata',
        'volume' => 80,
        'muted' => FALSE,
        'repeat' => 'none',
        'backgroundColor' => '000000',
        'mode' => 'playlist',
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function jplayer_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    case 'jplayer_player':
      if (!empty($items)) {
        $output = theme(
          'jplayer',
          array(
            'entity_type' => $entity_type,
            'entity' => $entity,
            'field_name' => $instance['field_name'],
            'items' => $items,
            'settings' => $display['settings'],
          )
        );
      }
      else {
        return array();
      }
      $element[0] = array(
        '#markup' => $output,
      );
      break;
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function jplayer_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $form = array();

  if ($display['type'] == 'jplayer_player') {
    $form['mode'] = array(
      '#title' => t('Kind'),
      '#type' => 'select',
      '#options' => array(
        'single' => t('Single'),
        'playlist' => t('Playlist'),
      ),
      '#default_value' => $settings['mode'],
    );

    $form['autoplay'] = array(
      '#title' => t('Autoplay'),
      '#type' => 'select',
      '#options' => array(
        0 => t('No'),
        1 => t('Yes'),
      ),
      '#default_value' => $settings['autoplay'],
    );

    $form['solution'] = array(
      '#title' => t('Preferred solution'),
      '#type' => 'select',
      '#options' => array(
        'html, flash' => t('HTML5'),
        'flash, html' => t('Flash'),
      ),
      '#default_value' => $settings['solution'],
    );

    $form['preload'] = array(
      '#title' => t('Preload media'),
      '#type' => 'select',
      '#options' => array(
        'metadata' => t('No'),
        'auto' => t('Yes'),
      ),
      '#description' => t("Preloading media before it's requested isn't available in all browsers."),
      '#default_value' => $settings['preload'],
    );

    $form['volume'] = array(
      '#title' => t('Initial volume'),
      '#type' => 'textfield',
      '#field_suffix' => '%',
      '#maxlength' => 3,
      '#size' => 3,
      '#default_value' => $settings['volume'],
      '#element_validate' => array('jplayer_volume_check'),
    );

    $form['muted'] = array(
      '#title' => t('Initially muted'),
      '#type' => 'select',
      '#options' => array(
        FALSE => t('No'),
        TRUE => t('Yes'),
      ),
      '#default_value' => $settings['muted'],
    );

    $form['repeat'] = array(
      '#title' => t('Repeat'),
      '#type' => 'select',
      '#options' => array(
        'all' => t('All'),
        'single' => t('Single'),
        'none' => t('None'),
      ),
      '#default_value' => $settings['repeat'],
    );

    $form['backgroundColor'] = array(
      '#title' => t('Background color'),
      '#type' => 'textfield',
      '#field_preffix' => '#',
      '#maxlength' => 6,
      '#size' => 6,
      '#default_value' => $settings['backgroundColor'],
    );
  }

  return $form;
}

/**
 * Element validation to check volume is between 0 and 100.
 */
function jplayer_volume_check($element, &$form_state) {
  $value = $element['#value'];

  if ($value < 0 || $value > 100) {
    form_set_error($element, t('Volume must be a percentage between 0% and 100%.'));
  }
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function jplayer_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = '';

  if ($display['type'] == 'jplayer_player') {
    if (isset($settings['autoplay']) && $settings['autoplay'] == 1) {
      $summary = t('Single jPlayer instance which autoplays.');
    }
    else {
      $summary = t('Single jPlayer instance.');
    }
  }

  return $summary;
}

/**
 * Implements hook_library().
 */
function jplayer_library() {
  $path = variable_get('jplayer_directory', 'sites/all/libraries/jplayer');
  $libraries = array();
  $libraries['jplayer'] = array(
    'title' => 'jPlayer',
    'website' => 'http://www.jplayer.org',
    'version' => '2.0',
    'js' => array(
      $path . '/jquery.jplayer.min.js' => array(),
    ),
  );
  return $libraries;
}

/**
 * Return the version of jPlayer installed.
 *
 * @param $directory
 *   The directory to check for a jPlayer installation.
 *
 * @return
 *   An array containing 'version', 'major, and 'minor' keys representing the
 *   version of jPlayer installed, or FALSE if a valid version number was not
 *   found.
 */
function jplayer_get_version($directory = NULL) {
  $version = 0;

  if (!isset($directory)) {
    $directory = variable_get('jplayer_directory', 'sites/all/libraries/jplayer');
  }

  if (file_exists($directory . '/jquery.jplayer.min.js')) {
    $contents = file_get_contents($directory . '/jquery.jplayer.min.js');
  }
  elseif (file_exists($directory . '/jquery.jplayer.js')) {
    $contents = file_get_contents($directory . '/jquery.jplayer.js');
  }
  else {
    return false;
  }

  $matches = array();
  preg_match('/Version:?[ ]*([\d.]+)/i', $contents, $matches);

  if (isset($matches[1])) {
    $version = $matches[1];
  }

  $parts = explode('.', $version);

  // Though other parts of the module may check for a specific version,
  // checking for a positive integer is more of a sanity check here.
  if ($version < 1 || !isset($parts[0]) || !isset($parts[1])) {
    return FALSE;
  }

  return array('version' => $version, 'major' => $parts[0], 'minor' => $parts[1]);
}

/**
 * Add core JS and CSS needed for jPlayer instances
 */
function jplayer_add_core_js() {
  $added = &drupal_static(__FUNCTION__, FALSE);
  if ($added) {
    // Js was already loaded.
    return;
  }
  $added = TRUE;

  // Add global settings
  $settings = array(
    'jPlayer' => array(
      'swfPath' => base_path() . variable_get('jplayer_directory', 'sites/all/libraries/jplayer'),
      'showHour' => (boolean)variable_get('jplayer_showHour', FALSE),
      'showMin' => (boolean)variable_get('jplayer_showMin', TRUE),
      'showSec' => (boolean)variable_get('jplayer_showSec', TRUE),
      'padHour' => (boolean)variable_get('jplayer_padHour', FALSE),
      'padMin' => (boolean)variable_get('jplayer_padMin', TRUE),
      'padSec' => (boolean)variable_get('jplayer_padSec', TRUE),
      'sepHour' => variable_get('jplayer_sepHour', ':'),
      'sepMin' => variable_get('jplayer_sepMin', ':'),
      'sepSec' => variable_get('jplayer_sepSec', ''),
    ),
  );
  drupal_add_js($settings, array('type' => 'setting'));

  $return = array(
    '#attached' => array(
      'library' => array(
        array('jplayer', 'jplayer'),
      ),
      'js' => array(
        drupal_get_path('module', 'jplayer') . '/theme/jplayer.js' => array('type' => 'file', 'scope' => 'footer', 'group' => JS_DEFAULT),
      ),
      'css' => array(
        drupal_get_path('module', 'jplayer') . '/theme/jplayer.css' => array('type' => 'file', 'group' => CSS_DEFAULT),
      ),
    ),
  );

  // Allow other modules to add resources to the page when a jPlayer is
  // embedded.
  if ($additional_resources = module_invoke_all('jplayer_add_js')) {
    $return['additional_resources'] = $additional_resources;
  }

  return $return;
}

/**
 * Implements hook_views_api().
 */
function jplayer_views_api() {
  return array(
    'path' => drupal_get_path('module', 'jplayer') . '/includes',
    'api' => 3.0,
  );
}

